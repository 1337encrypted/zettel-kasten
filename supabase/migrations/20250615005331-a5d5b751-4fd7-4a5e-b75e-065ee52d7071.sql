
-- Drop the existing is_admin function and dependent policies
DROP FUNCTION IF EXISTS public.is_admin(uuid) CASCADE;

-- Create an enum type for application roles if it doesn't exist
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'app_role') THEN
        CREATE TYPE public.app_role AS ENUM ('admin', 'user');
    END IF;
END$$;

-- Create a table to store user roles if it doesn't exist
CREATE TABLE IF NOT EXISTS public.user_roles (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    role public.app_role NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
    UNIQUE(user_id, role)
);

-- Enable Row Level Security on the user_roles table
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;

-- Recreate the is_admin function to check our new user_roles table
CREATE OR REPLACE FUNCTION public.is_admin(p_user_id uuid)
RETURNS boolean AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM public.user_roles
    WHERE user_id = p_user_id AND role = 'admin'
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant the 'admin' role to the original admin user
DO $$
DECLARE
    admin_user_id uuid;
BEGIN
    SELECT id INTO admin_user_id FROM public.profiles WHERE username = '1337encrypted' LIMIT 1;
    IF admin_user_id IS NOT NULL THEN
        INSERT INTO public.user_roles (user_id, role)
        VALUES (admin_user_id, 'admin')
        ON CONFLICT (user_id, role) DO NOTHING;
    END IF;
END $$;

-- RLS Policies for user_roles table
-- Drop existing policies before creating new ones to avoid errors on re-run
DROP POLICY IF EXISTS "Allow admins to view all user roles" ON public.user_roles;
CREATE POLICY "Allow admins to view all user roles"
ON public.user_roles FOR SELECT
TO authenticated
USING (public.is_admin(auth.uid()));

DROP POLICY IF EXISTS "Allow admins to manage user roles" ON public.user_roles;
CREATE POLICY "Allow admins to manage user roles"
ON public.user_roles FOR ALL
TO authenticated
USING (public.is_admin(auth.uid()))
WITH CHECK (public.is_admin(auth.uid()));

DROP POLICY IF EXISTS "Allow users to view their own roles" ON public.user_roles;
CREATE POLICY "Allow users to view their own roles"
ON public.user_roles FOR SELECT
TO authenticated
USING (auth.uid() = user_id);

-- RLS Policies for profiles table
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view their own profile." ON public.profiles;
CREATE POLICY "Users can view their own profile."
ON public.profiles FOR SELECT
USING (auth.uid() = id);

DROP POLICY IF EXISTS "Admins can view all profiles." ON public.profiles;
CREATE POLICY "Admins can view all profiles."
ON public.profiles FOR SELECT
USING (public.is_admin(auth.uid()));

DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;
CREATE POLICY "Users can update their own profile."
ON public.profiles FOR UPDATE
USING (auth.uid() = id)
WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Admins can update any profile." ON public.profiles;
CREATE POLICY "Admins can update any profile."
ON public.profiles FOR UPDATE
USING (public.is_admin(auth.uid()));

-- Recreate RLS policies for app_settings that were dropped by CASCADE
ALTER TABLE public.app_settings ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Allow admin to view app settings" ON public.app_settings;
CREATE POLICY "Allow admin to view app settings"
ON public.app_settings FOR SELECT
TO authenticated
USING (public.is_admin(auth.uid()));

DROP POLICY IF EXISTS "Allow admin to update app settings" ON public.app_settings;
CREATE POLICY "Allow admin to update app settings"
ON public.app_settings FOR ALL
TO authenticated
USING (public.is_admin(auth.uid()));
